Index: ffmpeg-6.0.1/libavformat/Makefile
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/Makefile
+++ ffmpeg-6.0.1/libavformat/Makefile
@@ -691,6 +691,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)
 OBJS-$(CONFIG_UDPLITE_PROTOCOL)          += udp.o ip.o
 OBJS-$(CONFIG_UNIX_PROTOCOL)             += unix.o
 
+# libav.js
+OBJS-$(CONFIG_JSFETCH_PROTOCOL)          += jsfetch.o
+# /libav.js
+
 # external library protocols
 OBJS-$(CONFIG_LIBAMQP_PROTOCOL)          += libamqp.o urldecode.o
 OBJS-$(CONFIG_LIBRIST_PROTOCOL)          += librist.o
Index: ffmpeg-6.0.1/libavformat/dashdec.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/dashdec.c
+++ ffmpeg-6.0.1/libavformat/dashdec.c
--- a/libavformat/dashdec.c
+++ b/libavformat/dashdec.c
@@ -401,6 +401,42 @@ static void free_subtitle_list(DASHContext *c)
     c->n_subtitles = 0;
 }
 
+static int jsfetch_wrap_url(const char *url, char *out_url)
+{
+    // Ensure the output buffer is always null-terminated initially
+    // to prevent issues with string functions like strncat.
+    out_url[0] = '\0';
+    size_t url_len = strlen(url);
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        const char *prefix = "jsfetch:";
+        size_t prefix_len = strlen(prefix);
+
+        strcpy(out_url, prefix);
+        strcat(out_url, url);
+
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *base_prefix = "crypto+";
+        size_t base_prefix_len = strlen(base_prefix);
+        const char *jsfetch_prefix = "jsfetch:";
+        size_t jsfetch_prefix_len = strlen(jsfetch_prefix);
+
+        // Calculate the tail of the URL (after "crypto+")
+        const char *url_tail = url + base_prefix_len;
+        size_t url_tail_len = strlen(url_tail);
+
+        strcpy(out_url, base_prefix);
+        strcat(out_url, jsfetch_prefix);
+        strcat(out_url, url_tail);
+
+    } else {
+        // No transformation needed; just copy original URL
+        strcpy(out_url, url);
+    }
+
+    return 0;
+}
+
 static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
                     AVDictionary **opts, AVDictionary *opts2, int *is_http)
 {
@@ -418,6 +454,9 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
     if (!proto_name)
         proto_name = avio_find_protocol_name(url);
 
+    av_log(NULL, AV_LOG_DEBUG, url);
+    av_log(NULL, AV_LOG_DEBUG, proto_name);
+
     if (!proto_name)
         return AVERROR_INVALIDDATA;
 
@@ -433,6 +472,8 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         }
     } else if (av_strstart(proto_name, "http", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -515,8 +556,17 @@ static char *get_content_url(xmlNodePtr *baseurl_nodes,
         }
     }
 end:
-    av_free(tmp_str);
-    return url;
+    // Longest is with crypto:jsfetch: prepended
+    char wrapped_url[MAX_URL_SIZE + 15];
+    int ret = jsfetch_wrap_url(url, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        return NULL;
+    }
+    av_free(url);
+    return av_strdup(wrapped_url);
+    // av_free(tmp_str);
+    // return url;
 }
 
 static char *get_val_from_nodes_tab(xmlNodePtr *nodes, const int n_nodes, const char *attrname)
@@ -1687,7 +1737,12 @@ static int open_input(DASHContext *c, struct representation *pls, struct fragmen
     char *url = NULL;
     int ret = 0;
 
+    // Longest is with crypto:jsfetch: prepended
+    // Can't put it later due to goto.
+    char wrapped_url[MAX_URL_SIZE + 15];
+
     url = av_mallocz(c->max_url_size);
+
     if (!url) {
         ret = AVERROR(ENOMEM);
         goto cleanup;
@@ -1698,9 +1753,31 @@ static int open_input(DASHContext *c, struct representation *pls, struct fragmen
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
+
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
+        
+        av_log(NULL, AV_LOG_DEBUG, range_header);
     }
+    // Custom value used by us in jsfetch to prevent unnecessary seeking.
+    av_dict_set_int(&opts, "skip_seek", 1, 0);
 
     ff_make_absolute_url(url, c->max_url_size, c->base_url, seg->url);
+    ret = jsfetch_wrap_url(url, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        goto cleanup;
+    } else {
+        av_free(url);
+        url = av_strdup(wrapped_url);
+    }
     av_log(pls->parent, AV_LOG_VERBOSE, "DASH request for url '%s', offset %"PRId64"\n",
            url, seg->url_offset);
     ret = open_url(pls->parent, &pls->input, url, &c->avio_opts, opts, NULL);
Index: ffmpeg-6.0.1/libavformat/hls.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/hls.c
+++ ffmpeg-6.0.1/libavformat/hls.c
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -311,6 +311,44 @@ static void free_rendition_list(HLSContext *c)
     c->n_renditions = 0;
 }
 
+// When the M3U8 contains any absolute URIs - i.e init segment, AES key, or just normal segments,
+// the jsfetch: protocol needs to be prepended.
+static int jsfetch_wrap_url(const char *url, char *out_url)
+{
+    // Ensure the output buffer is always null-terminated initially
+    // to prevent issues with string functions like strncat.
+    out_url[0] = '\0';
+    size_t url_len = strlen(url);
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        const char *prefix = "jsfetch:";
+        size_t prefix_len = strlen(prefix);
+
+        strcpy(out_url, prefix);
+        strcat(out_url, url);
+
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *base_prefix = "crypto+";
+        size_t base_prefix_len = strlen(base_prefix);
+        const char *jsfetch_prefix = "jsfetch:";
+        size_t jsfetch_prefix_len = strlen(jsfetch_prefix);
+
+        // Calculate the tail of the URL (after "crypto+")
+        const char *url_tail = url + base_prefix_len;
+        size_t url_tail_len = strlen(url_tail);
+
+        strcpy(out_url, base_prefix);
+        strcat(out_url, jsfetch_prefix);
+        strcat(out_url, url_tail);
+
+    } else {
+        // No transformation needed; just copy original URL
+        strcpy(out_url, url);
+    }
+
+    return 0;
+}
+
 static struct playlist *new_playlist(HLSContext *c, const char *url,
                                      const char *base)
 {
@@ -438,7 +476,16 @@ static struct segment *new_init_section(struct playlist *pls,
             return NULL;
         }
     }
-    sec->url = av_strdup(ptr);
+    // Longest is with crypto:jsfetch: prepended
+    char wrapped_url[MAX_URL_SIZE + 15];
+    int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        av_free(sec);
+        return NULL;
+    } else {
+        sec->url = av_strdup(wrapped_url);
+    }
     if (!sec->url) {
         av_free(sec);
         return NULL;
@@ -680,6 +727,8 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -956,14 +1005,18 @@ static int parse_playlist(HLSContext *c, const char *url,
                     AV_WB64(seg->iv + 8, seq);
                 }
 
+                // Longest is with crypto:jsfetch: prepended
+                char wrapped_url[MAX_URL_SIZE + 15];
+
                 if (key_type != KEY_NONE) {
                     ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);
-                    if (!tmp_str[0]) {
+                    int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+                    if (ret < 0) {
                         ret = AVERROR_INVALIDDATA;
                         av_free(seg);
                         goto fail;
                     }
-                    seg->key = av_strdup(tmp_str);
+                    seg->key = av_strdup(wrapped_url);
                     if (!seg->key) {
                         av_free(seg);
                         ret = AVERROR(ENOMEM);
@@ -981,7 +1034,14 @@ static int parse_playlist(HLSContext *c, const char *url,
                     av_free(seg);
                     goto fail;
                 }
-                seg->url = av_strdup(tmp_str);
+                int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+                if (ret < 0) {
+                    fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+                    av_free(seg);
+                    goto fail;
+                } else {
+                    seg->url = av_strdup(wrapped_url);
+                }
                 if (!seg->url) {
                     av_free(seg->key);
                     av_free(seg);
@@ -1294,7 +1354,19 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
-    }
+
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
+      }
+      // Custom value used by us in jsfetch to prevent unnecessary seeking.
+      av_dict_set_int(&opts, "skip_seek", 1, 0);
 
     av_log(pls->parent, AV_LOG_VERBOSE, "HLS request for url '%s', offset %"PRId64", playlist %d\n",
            seg->url, seg->url_offset, pls->index);
@@ -1348,14 +1420,15 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
      * as would be expected. Wrong offset received from the server will not be
      * noticed without the call, though.
      */
-    if (ret == 0 && !is_http && seg->url_offset) {
-        int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
-        if (seekret < 0) {
-            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
-            ret = seekret;
-            ff_format_io_close(pls->parent, in);
-        }
-    }
+    // Breaks seeking on M3U8s containing byte ranges. Not needed for "http" anyways.
+    // if (ret == 0 && !is_http && seg->url_offset) {
+    //     int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
+    //     if (seekret < 0) {
+    //         av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
+    //         ret = seekret;
+    //         ff_format_io_close(pls->parent, in);
+    //     }
+    // }
 
 cleanup:
     av_dict_free(&opts);
@@ -2540,25 +2613,27 @@ static int hls_probe(const AVProbeData *p)
         strstr(p->buf, "#EXT-X-TARGETDURATION:") ||
         strstr(p->buf, "#EXT-X-MEDIA-SEQUENCE:")) {
 
-        int mime_ok = p->mime_type && !(
-            av_strcasecmp(p->mime_type, "application/vnd.apple.mpegurl") &&
-            av_strcasecmp(p->mime_type, "audio/mpegurl")
-            );
-
-        int mime_x = p->mime_type && !(
-            av_strcasecmp(p->mime_type, "audio/x-mpegurl") &&
-            av_strcasecmp(p->mime_type, "application/x-mpegurl")
-            );
-
-        if (!mime_ok &&
-            !mime_x &&
-            !av_match_ext    (p->filename, "m3u8,m3u") &&
-             ff_match_url_ext(p->filename, "m3u8,m3u") <= 0) {
-            av_log(NULL, AV_LOG_ERROR, "Not detecting m3u8/hls with non standard extension and non standard mime type\n");
-            return 0;
-        }
-        if (mime_x)
-            av_log(NULL, AV_LOG_WARNING, "mime type is not rfc8216 compliant\n");
+        // Don't worry about MIME type. Close enough if it has the above.
+
+        // int mime_ok = p->mime_type && !(
+        //     av_strcasecmp(p->mime_type, "application/vnd.apple.mpegurl") &&
+        //     av_strcasecmp(p->mime_type, "audio/mpegurl")
+        //     );
+
+        // int mime_x = p->mime_type && !(
+        //     av_strcasecmp(p->mime_type, "audio/x-mpegurl") &&
+        //     av_strcasecmp(p->mime_type, "application/x-mpegurl")
+        //     );
+
+        // if (!mime_ok &&
+        //     !mime_x &&
+        //     !av_match_ext    (p->filename, "m3u8,m3u") &&
+        //      ff_match_url_ext(p->filename, "m3u8,m3u") <= 0) {
+        //     av_log(NULL, AV_LOG_ERROR, "Not detecting m3u8/hls with non standard extension and non standard mime type\n");
+        //     return 0;
+        // }
+        // if (mime_x)
+        //     av_log(NULL, AV_LOG_WARNING, "mime type is not rfc8216 compliant\n");
 
         return AVPROBE_SCORE_MAX;
     }
 Index: ffmpeg-6.0.1/libavformat/url.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/url.c
+++ ffmpeg-6.0.1/libavformat/url.c
--- a/libavformat/url.c
+++ b/libavformat/url.c
@@ -201,6 +201,11 @@ int ff_make_absolute_url2(char *buf, int size, const char *base,
     int use_base_path, simplify_path = 0, ret;
     const char *base_separators = "/";
 
+    // Adjust base pointer to skip "jsfetch:" if exists
+    if (av_strstart(base, "jsfetch:", NULL)) {
+        base = base + 8; 
+    }
+
     /* This is tricky.
        For HTTP, http://server/site/page + ../media/file
        should resolve into http://server/media/file

 Index: ffmpeg-6.0.1/libavformat/jsfetch.h
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.h
@@ -0,0 +1,6 @@
+#ifndef JSFETCH_H
+#define JSFETCH_H
+
+void jsfetch_abort_request(void);
+
+#endif
 Index: ffmpeg-6.0.1/libavformat/jsfetch.c
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.c
@@ -0,0 +1,398 @@
+/*
+ * JavaScript fetch metaprotocol for ffmpeg client
+ * Copyright (c) 2023 Yahweasel and contributors
+ *
+ * This file is part of FFmpeg in libav.js. The following license applies only
+ * to this file.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "libavutil/error.h"
+#include "libavutil/opt.h"
+
+#include "url.h"
+#include "jsfetch.h"
+
+#include <emscripten.h>
+#include <errno.h>
+
+typedef struct JSFetchContext {
+    const AVClass *class;
+    // All of the real information is stored in a JavaScript structure
+    int idx;
+} JSFetchContext;
+
+static const AVOption options[] = {
+    { NULL }
+};
+#define CONFIG_JSFETCH_PROTOCOL 1
+#if CONFIG_JSFETCH_PROTOCOL
+static const AVClass jsfetch_context_class = {
+    .class_name = "jsfetch",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT
+};
+
+EM_JS(void, jsfetch_abort, (), {
+    var abortController = Module.libavjsJSFetch.abortController;
+    if (abortController) {
+        abortController.abort();
+    }
+});
+
+void jsfetch_abort_request(void) {
+  jsfetch_abort();
+}
+
+/**
+ * Open a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_open_js, (const char* url, char* range_header, bool has_range, int force_idx), {
+    return Asyncify.handleAsync(function() {
+      if (!Module.libavjsJSFetch)
+        Module.libavjsJSFetch = {ctr: 1, fetches: {}, abortController: new AbortController()};
+      return Promise.all([]).then(function() {
+        url = UTF8ToString(url);
+        var headers = {};
+        if (has_range) {
+          var range = range_header ? UTF8ToString(range_header) : undefined;
+          headers.Range = range;
+        }
+        var fetchUrl = url.startsWith("jsfetch:") ? url.slice(8) : url;
+        
+        // Retry function with exponential backoff
+        function fetchWithRetry(retryCount) {
+          return fetch(fetchUrl, { headers, signal: Module.libavjsJSFetch.abortController.signal }).then(function(response) {
+            // Check for HTTP errors (4xx/5xx status codes)
+            if (!response.ok) {
+              var error = new Error('HTTP Error: ' + response.status + ' ' + response.statusText);
+              error.status = response.status;
+              error.response = response;
+              throw error;
+            }
+            return response;
+          }).catch(function(error) {
+            // No retry
+            if (error instanceof DOMException && error.name == 'AbortError') {
+              return error;
+            }
+
+            console.warn("Caught error", error);
+            var shouldRetry = error.status && (error.status >= 500 || error.status == 429 || error.status == 408);
+
+            // Retry for all exceptions, and 5xx.
+            if (shouldRetry && retryCount < 5) {
+              console.warn('Fetch attempt ' + (retryCount + 1) + ' failed for ' + fetchUrl + 
+                          ', retrying in ' + Math.pow(2, retryCount) * 250 + 'ms...', error);
+              
+              // Exponential backoff: [250ms -> 4s]
+              var delay = Math.pow(2, retryCount) * 250;
+              return new Promise(function(resolve) {
+                let timeoutId = setTimeout(resolve, delay);
+                Module.libavjsJSFetch.abortController.signal.addEventListener('abort', () => {
+                  clearTimeout(timeoutId);
+                  resolve();
+                  error.aborted = true
+                });
+
+              }).then(function() {
+                if (error.aborted) {
+                  return error;
+                } else {
+                  return fetchWithRetry(retryCount + 1);
+                }
+              });
+            }
+            
+            // For dash, ffmpeg keeps going past the last segment for some reason
+            // that happens even on ffmpeg-cli. It will be a 404.
+            // For other errors, lets try to return a partial download.
+            return error;
+          });
+        }
+        
+        return fetchWithRetry(0);
+      }).then(function(response) {
+        if (response.name == 'AbortError' || response.aborted) {
+          return -0x54584945; /* AVERROR_EXIT*/
+        }
+        if (response instanceof Error) {
+          // Should return a partial file if we've downloaded anything so far.
+          return -0x20464f45 /* AVERROR_EOF */;
+        }
+        var jsf = Module.libavjsJSFetch;
+
+        const accept_range = (response.headers.get("accept-ranges") || "").toLowerCase();
+        const support_range = accept_range && accept_range == "bytes";
+        const content_length = parseInt(response.headers.get("content-length") || "0", 10);
+
+        if (!jsf.support_range) {
+          jsf.support_range = support_range;
+        }
+
+        // This could be a range request, so don't overwrite.
+        if (!jsf.content_length) {
+          jsf.content_length = content_length;
+        }
+
+        var idx = force_idx ? force_idx : jsf.ctr++;
+        var reader = response.body.getReader();
+        var jsfo = jsf.fetches[idx] = {
+          url: url,
+          response: response,
+          reader: reader,
+          next: reader.read().then(function(res) {
+            jsfo.buf = res;
+          }).catch(function(rej) {
+            jsfo.rej = rej;
+          }),
+          buf: null,
+          rej: null
+        };
+        return idx;
+      }).catch(function(ex) {
+        Module.fsThrownError = ex;
+        console.error('Final fetch error after retries:', ex);
+        return -6 /* EAGAIN */;
+      });
+    });
+   });
+
+/**
+ * Check byte range support
+ */
+EM_JS(int, jsfetch_support_range_js, (), {
+  var jsf = Module.libavjsJSFetch;
+  var ret = jsf.support_range ? 1 : 0;
+  return ret;
+});
+
+/**
+ * Check size
+ */
+EM_JS(double, jsfetch_get_size_js, (), {
+  var jsf = Module.libavjsJSFetch;
+  var size = jsf.content_length ? jsf.content_length : 0;
+
+  return size;
+});
+
+/**
+ * Get curr position
+ */
+EM_JS(double, jsfetch_get_pos_js, (), {
+  var jsf = Module.libavjsJSFetch;
+  var pos = jsf.pos ? jsf.pos : 0;
+  return pos;
+});
+
+/**
+ * Set curr position
+ */
+EM_JS(void, jsfetch_set_pos_js, (double pos), {
+  var jsf = Module.libavjsJSFetch;
+  jsf.pos = pos;
+});
+
+/**
+ * Open a fetch connection.
+ */
+static int jsfetch_open(URLContext *h, const char *url, int flags, AVDictionary **options)
+{
+    JSFetchContext *ctx = h->priv_data;
+
+    AVDictionaryEntry *entry = av_dict_get(*options, "range_header", NULL, 0);
+    const char *range_ptr = entry ? entry->value : NULL;
+    bool has_range = range_ptr != NULL;
+    ctx->idx = jsfetch_open_js(url, range_ptr, has_range, 0);
+
+    // Check for our special header to indicate this is M3U8/DASH and should not seek.
+    // Those formats can seek within the playlist, but not within an individual segment.
+    entry = av_dict_get(*options, "skip_seek", NULL, 0);
+
+   if (entry || has_range) {
+       // Don't seek.
+       h->is_streamed = 1;
+   } else {
+       // Seek if range header is supported.
+       int support = jsfetch_support_range_js();
+       h->is_streamed = (bool) !support;
+   }
+
+    return (ctx->idx > 0) ? 0 : ctx->idx;
+}
+
+/**
+ * Read from a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_read_js, (int idx, unsigned char *toBuf, int size), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    if (!jsfo) {
+      console.warn("Null jsfo. Probably aborted.");
+      return -0x54584945; /* AVERROR_EXIT*/
+    }
+    return Asyncify.handleAsync(function() { return Promise.all([]).then(function() {
+        if (jsfo.buf || jsfo.rej) {
+            // Already have data
+            var fromBuf = jsfo.buf;
+            var rej = jsfo.rej;
+
+            if (fromBuf) {
+                if (fromBuf.done) {
+                    // EOF
+                    return -0x20464f45 /* AVERROR_EOF */;
+                }
+                if (fromBuf.value.length > size) {
+                    // Return some of the buffer
+                    Module.HEAPU8.set(fromBuf.value.subarray(0, size), toBuf);
+                    fromBuf.value = fromBuf.value.subarray(size);
+                    return size;
+                }
+
+                /* Otherwise, return the remainder of the buffer and start
+                 * the next read */
+                var ret = fromBuf.value.length;
+                Module.HEAPU8.set(fromBuf.value, toBuf);
+                jsfo.buf = jsfo.rej = null;
+                jsfo.next = jsfo.reader.read().then(function(res) {
+                    jsfo.buf = res;
+                }).catch(function(rej) {
+                    jsfo.rej = rej;
+                });
+                return ret;
+            }
+
+            if (rej.name == 'AbortError') {
+              return -0x54584945; /* AVERROR_EXIT*/
+            }
+
+            // Otherwise, there was an error
+            Module.fsThrownError = rej;
+            console.error(rej);
+            return -11 /* ECANCELED */;
+        }
+
+        // The next data isn't available yet. Force them to wait.
+        return Promise.race([
+            jsfo.next,
+            new Promise(function(res) { setTimeout(res, 100); })
+        ]).then(function() { return -6 /* EAGAIN */; });
+    }); });
+});
+
+/**
+ * Read from a fetch connection.
+ */
+static int jsfetch_read(URLContext *h, unsigned char *buf, int size)
+{
+    JSFetchContext *ctx = h->priv_data;
+    return jsfetch_read_js(ctx->idx, buf, size);
+}
+
+/**
+ * Close a fetch connection (JavaScript side).
+ */
+EM_JS(void, jsfetch_close_js, (int idx), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    if (jsfo) {
+        try { jsfo.reader.cancel(); } catch (ex) {}
+        delete Module.libavjsJSFetch.fetches[idx];
+    }
+});
+
+/**
+ * Close a fetch connection.
+ */
+static int jsfetch_close(URLContext *h)
+{
+    JSFetchContext *ctx = h->priv_data;
+    jsfetch_close_js(ctx->idx);
+    return 0;
+}
+
+// Note: Use double for size/pos. Otherwise we can overflow.
+// Works up to 2^53 bytes ~ 9PB, so should be fine.
+// EM_JS can't handle int64_t without the -sWASM_BIGINT build flag. 
+// Building with it might mess up ffmpeg function bindings that do int64_t => {lo, hi} conversion.
+// https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-pass-int64-t-and-uint64-t-values-from-js-into-wasm-functions
+static int64_t jsfetch_seek(URLContext *h, int64_t pos, int whence)
+{
+    av_log(h, AV_LOG_DEBUG, "[jsfetch] Seeking to pos=%" PRId64 ", whence=%d, url=%s\n",
+           pos, whence, h->filename);
+
+    JSFetchContext *ctx = h->priv_data;
+
+    if (h->is_streamed) {
+         return AVERROR(ENOSYS); 
+    }
+     // AVSEEK_SIZE - should return the size
+    int64_t size = (double) jsfetch_get_size_js();
+    if (whence == 0x10000) {
+      return size ? size : -38;// AVERROR(ENOSYS)
+    }
+
+    // SEEK_CUR: Seek to curr + pos. Very unlikely.
+    if (whence == 1) {
+      double curr_pos = jsfetch_get_pos_js();
+      pos += (int64_t) curr_pos;
+    }
+
+    // SEEK_END: Seek to end of stream + pos.
+    // Usually pos is -1.
+    if (whence == 2) {
+      double size = jsfetch_get_size_js();
+      pos += (int64_t) size;
+    }
+
+    // In case SEEK_CUR is called later.
+    jsfetch_set_pos_js((double) pos);
+
+    int ret = jsfetch_close(h);
+    if (ret < 0) {
+        av_log(h, AV_LOG_ERROR, "[jsfetch] jsfetch_close failed with error %d\n", ret);
+        return ret;
+    }
+    int has_range = (pos >= 0);
+    char range_header_buf[128];
+    char *range_header = NULL;
+    if (has_range) {
+        // "bytes=<start>-"
+        snprintf(range_header_buf, sizeof(range_header_buf), "bytes=%" PRId64 "-", pos);
+        range_header = range_header_buf;
+    }
+
+    // Force the same idx
+    ret = jsfetch_open_js(h->filename, range_header, has_range, ctx->idx);
+    if (ret < 0) {
+      return ret;
+    }
+
+    return pos;
+}
+
+const URLProtocol ff_jsfetch_protocol = {
+    .name               = "jsfetch",
+    .url_open2          = jsfetch_open,
+    .url_read           = jsfetch_read,
+    .url_close          = jsfetch_close,
+    .url_seek           = jsfetch_seek,
+    .priv_data_size     = sizeof(JSFetchContext),
+    .priv_data_class    = &jsfetch_context_class,
+    .flags              = URL_PROTOCOL_FLAG_NETWORK,
+    .default_whitelist  = "jsfetch,http,https,crypto"
+};
+#endif
Index: ffmpeg-6.0.1/libavformat/protocols.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/protocols.c
+++ ffmpeg-6.0.1/libavformat/protocols.c
@@ -76,6 +76,10 @@ extern const URLProtocol ff_libzmq_proto
 extern const URLProtocol ff_ipfs_gateway_protocol;
 extern const URLProtocol ff_ipns_gateway_protocol;
 
+/* libav.js */
+extern const URLProtocol ff_jsfetch_protocol;
+/* /libav.js */
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)

Index: ffmpeg-6.0.1/libavformat/mov.c
===================================================================
From https://trac.ffmpeg.org/ticket/7359
https://github.com/FFmpeg/FFmpeg/commit/380a518c439d4e5e3cf17b97e4a06259e8048f99
Note: this patch isn't in 7.1.1.
--- ffmpeg-6.0.1.orig/libavformat/mov.c
+++ ffmpeg-6.0.1/libavformat/mov.c
@@ -10416,15 +10416,15 @@ static int mov_switch_root(AVFormatContext *s, int64_t target, int index)
 
     if (index >= 0 && index < mov->frag_index.nb_items)
         target = mov->frag_index.item[index].moof_offset;
-    if (avio_seek(s->pb, target, SEEK_SET) != target) {
+    if (target >= 0 && avio_seek(s->pb, target, SEEK_SET) != target) {
         av_log(mov->fc, AV_LOG_ERROR, "root atom offset 0x%"PRIx64": partial file\n", target);
         return AVERROR_INVALIDDATA;
     }
 
     mov->next_root_atom = 0;
-    if (index < 0 || index >= mov->frag_index.nb_items)
+    if ((index < 0 && target >= 0) || index >= mov->frag_index.nb_items)
         index = search_frag_moof_offset(&mov->frag_index, target);
-    if (index < mov->frag_index.nb_items &&
+    if (index >= 0 && index < mov->frag_index.nb_items &&
         mov->frag_index.item[index].moof_offset == target) {
         if (index + 1 < mov->frag_index.nb_items)
             mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;
@@ -10554,10 +10554,43 @@ static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
     MOVStreamContext *sc;
     AVIndexEntry *sample;
     AVStream *st = NULL;
+    FFStream *avsti = NULL;
     int64_t current_index;
     int ret;
+    int i;
     mov->fc = s;
  retry:
+        if (s->pb->pos == 0) {
+
+        // Discard current fragment index
+        if (mov->frag_index.allocated_size > 0) {
+            av_freep(&mov->frag_index.item);
+            mov->frag_index.nb_items = 0;
+            mov->frag_index.allocated_size = 0;
+            mov->frag_index.current = -1;
+            mov->frag_index.complete = 0;
+        }
+
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *avst = s->streams[i];
+            MOVStreamContext *msc = avst->priv_data;
+
+            // Clear current sample
+            mov_current_sample_set(msc, 0);
+            msc->ctts_index = 0;
+
+            // Discard current index entries
+            avsti = ffstream(avst);
+            if (avsti->index_entries_allocated_size > 0) {
+                av_freep(&avsti->index_entries);
+                avsti->index_entries_allocated_size = 0;
+                avsti->nb_index_entries = 0;
+            }
+        }
+
+        if ((ret = mov_switch_root(s, -1, -1)) < 0)
+            return ret;
+    }
     sample = mov_find_next_sample(s, &st);
     if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {
         if (!mov->next_root_atom)