Index: ffmpeg-6.0.1/libavformat/Makefile
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/Makefile
+++ ffmpeg-6.0.1/libavformat/Makefile
@@ -691,6 +691,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)
 OBJS-$(CONFIG_UDPLITE_PROTOCOL)          += udp.o ip.o
 OBJS-$(CONFIG_UNIX_PROTOCOL)             += unix.o
 
+# libav.js
+OBJS-$(CONFIG_JSFETCH_PROTOCOL)          += jsfetch.o
+# /libav.js
+
 # external library protocols
 OBJS-$(CONFIG_LIBAMQP_PROTOCOL)          += libamqp.o urldecode.o
 OBJS-$(CONFIG_LIBRIST_PROTOCOL)          += librist.o
Index: ffmpeg-6.0.1/libavformat/hls.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/hls.c
+++ ffmpeg-6.0.1/libavformat/hls.c
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -311,6 +311,44 @@ static void free_rendition_list(HLSContext *c)
     c->n_renditions = 0;
 }
 
+// When the M3U8 contains any absolute URIs - i.e init segment, AES key, or just normal segments,
+// the jsfetch: protocol needs to be prepended.
+static int jsfetch_wrap_url(const char *url, char *out_url)
+{
+    // Ensure the output buffer is always null-terminated initially
+    // to prevent issues with string functions like strncat.
+    out_url[0] = '\0';
+    size_t url_len = strlen(url);
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        const char *prefix = "jsfetch:";
+        size_t prefix_len = strlen(prefix);
+
+        strcpy(out_url, prefix);
+        strcat(out_url, url);
+
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *base_prefix = "crypto+";
+        size_t base_prefix_len = strlen(base_prefix);
+        const char *jsfetch_prefix = "jsfetch:";
+        size_t jsfetch_prefix_len = strlen(jsfetch_prefix);
+
+        // Calculate the tail of the URL (after "crypto+")
+        const char *url_tail = url + base_prefix_len;
+        size_t url_tail_len = strlen(url_tail);
+
+        strcpy(out_url, base_prefix);
+        strcat(out_url, jsfetch_prefix);
+        strcat(out_url, url_tail);
+
+    } else {
+        // No transformation needed; just copy original URL
+        strcpy(out_url, url);
+    }
+
+    return 0;
+}
+
 static struct playlist *new_playlist(HLSContext *c, const char *url,
                                      const char *base)
 {
@@ -438,7 +476,16 @@ static struct segment *new_init_section(struct playlist *pls,
             return NULL;
         }
     }
-    sec->url = av_strdup(ptr);
+    // Longest is with crypto:jsfetch: prepended
+    char wrapped_url[MAX_URL_SIZE + 15];
+    int ret = jsfetch_wrap_url(tmp_str, &wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        av_free(sec);
+        return NULL;
+    } else {
+        sec->url = av_strdup(wrapped_url);
+    }
     if (!sec->url) {
         av_free(sec);
         return NULL;
@@ -680,6 +727,8 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -956,14 +1005,18 @@ static int parse_playlist(HLSContext *c, const char *url,
                     AV_WB64(seg->iv + 8, seq);
                 }
 
+                // Longest is with crypto:jsfetch: prepended
+                char wrapped_url[MAX_URL_SIZE + 15];
+
                 if (key_type != KEY_NONE) {
                     ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);
-                    if (!tmp_str[0]) {
+                    int ret = jsfetch_wrap_url(tmp_str, &wrapped_url);
+                    if (ret < 0) {
                         ret = AVERROR_INVALIDDATA;
                         av_free(seg);
                         goto fail;
                     }
-                    seg->key = av_strdup(tmp_str);
+                    seg->key = av_strdup(wrapped_url);
                     if (!seg->key) {
                         av_free(seg);
                         ret = AVERROR(ENOMEM);
@@ -981,7 +1034,14 @@ static int parse_playlist(HLSContext *c, const char *url,
                     av_free(seg);
                     goto fail;
                 }
-                seg->url = av_strdup(tmp_str);
+                int ret = jsfetch_wrap_url(tmp_str, &wrapped_url);
+                if (ret < 0) {
+                    fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+                    av_free(seg);
+                    goto fail;
+                } else {
+                    seg->url = av_strdup(wrapped_url);
+                }
                 if (!seg->url) {
                     av_free(seg->key);
                     av_free(seg);
@@ -1294,6 +1354,16 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
+
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
     }
 
     av_log(pls->parent, AV_LOG_VERBOSE, "HLS request for url '%s', offset %"PRId64", playlist %d\n",
@@ -1348,14 +1418,15 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
      * as would be expected. Wrong offset received from the server will not be
      * noticed without the call, though.
      */
-    if (ret == 0 && !is_http && seg->url_offset) {
-        int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
-        if (seekret < 0) {
-            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
-            ret = seekret;
-            ff_format_io_close(pls->parent, in);
-        }
-    }
+    // Breaks seeking on M3U8s containing byte ranges. Not needed for "http" anyways.
+    // if (ret == 0 && !is_http && seg->url_offset) {
+    //     int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
+    //     if (seekret < 0) {
+    //         av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
+    //         ret = seekret;
+    //         ff_format_io_close(pls->parent, in);
+    //     }
+    // }
 
 cleanup:
     av_dict_free(&opts);
 Index: ffmpeg-6.0.1/libavformat/url.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/url.c
+++ ffmpeg-6.0.1/libavformat/url.c
--- a/libavformat/url.c
+++ b/libavformat/url.c
@@ -201,6 +201,11 @@ int ff_make_absolute_url2(char *buf, int size, const char *base,
     int use_base_path, simplify_path = 0, ret;
     const char *base_separators = "/";
 
+    // Adjust base pointer to skip "jsfetch:" if exists
+    if (av_strstart(base, "jsfetch:", NULL)) {
+        base = base + 8; 
+    }
+
     /* This is tricky.
        For HTTP, http://server/site/page + ../media/file
        should resolve into http://server/media/file

 Index: ffmpeg-6.0.1/libavformat/jsfetch.c
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.c
@@ -0,0 +1,237 @@
+/*
+ * JavaScript fetch metaprotocol for ffmpeg client
+ * Copyright (c) 2023 Yahweasel and contributors
+ *
+ * This file is part of FFmpeg in libav.js. The following license applies only
+ * to this file.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "libavutil/error.h"
+#include "libavutil/opt.h"
+
+#include "url.h"
+
+#include <emscripten.h>
+#include <errno.h>
+
+typedef struct JSFetchContext {
+    const AVClass *class;
+    // All of the real information is stored in a JavaScript structure
+    int idx;
+} JSFetchContext;
+
+static const AVOption options[] = {
+    { NULL }
+};
+
+#if CONFIG_JSFETCH_PROTOCOL
+static const AVClass jsfetch_context_class = {
+    .class_name = "jsfetch",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT
+};
+
+/**
+ * Open a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_open_js, (const char* url, char* range_header, bool has_range), {
+    return Asyncify.handleAsync(function() {
+      return Promise.all([]).then(function() {
+        url = UTF8ToString(url);
+        var headers = {};
+        if (has_range) {
+          var range = range_header ? UTF8ToString(range_header) : undefined;
+          headers.Range = range;
+        }
+        var fetchUrl = url.startsWith("jsfetch:") ? url.slice(8) : url;
+        
+        // Retry function with exponential backoff
+        function fetchWithRetry(retryCount) {
+          return fetch(fetchUrl, { headers }).then(function(response) {
+            // Check for HTTP errors (4xx/5xx status codes)
+            if (!response.ok) {
+              var error = new Error('HTTP Error: ' + response.status + ' ' + response.statusText);
+              error.status = response.status;
+              error.response = response;
+              throw error;
+            }
+            return response;
+          }).catch(function(error) {
+            // Retry for all exceptions, but not for status codes < 500
+            if (retryCount < 5) {
+              var shouldRetry = true;
+              console.warn("Caught error", error);
+              // Don't retry for client errors (4xx status codes)
+              // Only check status if it exists (we set it for HTTP errors)
+              if (error.status && error.status >= 400 && error.status < 500) {
+                shouldRetry = false;
+              }
+              
+              if (shouldRetry) {
+                console.warn('Fetch attempt ' + (retryCount + 1) + ' failed for ' + fetchUrl + 
+                            ', retrying in ' + Math.pow(2, retryCount) * 250 + 'ms...', error);
+                
+                // Exponential backoff: [250ms -> 4s]
+                var delay = Math.pow(2, retryCount) * 250;
+                return new Promise(function(resolve) {
+                  setTimeout(resolve, delay);
+                }).then(function() {
+                  return fetchWithRetry(retryCount + 1);
+                });
+              }
+            }
+            
+            // Re-throw error if max retries exceeded or non-retryable error
+            throw error;
+          });
+        }
+        
+        return fetchWithRetry(0);
+      }).then(function(response) {
+        if (!Module.libavjsJSFetch)
+          Module.libavjsJSFetch = {ctr: 1, fetches: {}};
+        var jsf = Module.libavjsJSFetch;
+        var idx = jsf.ctr++;
+        var reader = response.body.getReader();
+        var jsfo = jsf.fetches[idx] = {
+          url: url,
+          response: response,
+          reader: reader,
+          next: reader.read().then(function(res) {
+            jsfo.buf = res;
+          }).catch(function(rej) {
+            jsfo.rej = rej;
+          }),
+          buf: null,
+          rej: null
+        };
+        return idx;
+      }).catch(function(ex) {
+        Module.fsThrownError = ex;
+        console.error('Final fetch error after retries:', ex);
+        return -6 /* EAGAIN */;
+      });
+    });
+   });
+
+/**
+ * Open a fetch connection.
+ */
+static int jsfetch_open(URLContext *h, const char *url, int flags, AVDictionary **options)
+{
+    JSFetchContext *ctx = h->priv_data;
+    h->is_streamed = 1;
+
+    AVDictionaryEntry *entry = av_dict_get(*options, "range_header", NULL, 0);
+    const char *range_ptr = entry ? entry->value : NULL;
+    bool has_range = range_ptr != NULL;
+    ctx->idx = jsfetch_open_js(url, range_ptr, has_range);
+    return (ctx->idx > 0) ? 0 : ctx->idx;
+}
+
+/**
+ * Read from a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_read_js, (int idx, unsigned char *toBuf, int size), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    return Asyncify.handleAsync(function() { return Promise.all([]).then(function() {
+        if (jsfo.buf || jsfo.rej) {
+            // Already have data
+            var fromBuf = jsfo.buf;
+            var rej = jsfo.rej;
+
+            if (fromBuf) {
+                if (fromBuf.done) {
+                    // EOF
+                    return -0x20464f45 /* AVERROR_EOF */;
+                }
+                if (fromBuf.value.length > size) {
+                    // Return some of the buffer
+                    Module.HEAPU8.set(fromBuf.value.subarray(0, size), toBuf);
+                    fromBuf.value = fromBuf.value.subarray(size);
+                    return size;
+                }
+
+                /* Otherwise, return the remainder of the buffer and start
+                 * the next read */
+                var ret = fromBuf.value.length;
+                Module.HEAPU8.set(fromBuf.value, toBuf);
+                jsfo.buf = jsfo.rej = null;
+                jsfo.next = jsfo.reader.read().then(function(res) {
+                    jsfo.buf = res;
+                }).catch(function(rej) {
+                    jsfo.rej = rej;
+                });
+                return ret;
+            }
+
+            // Otherwise, there was an error
+            Module.fsThrownError = rej;
+            console.error(rej);
+            return -11 /* ECANCELED */;
+        }
+
+        // The next data isn't available yet. Force them to wait.
+        return Promise.race([
+            jsfo.next,
+            new Promise(function(res) { setTimeout(res, 100); })
+        ]).then(function() { return -6 /* EAGAIN */; });
+    }); });
+});
+
+/**
+ * Read from a fetch connection.
+ */
+static int jsfetch_read(URLContext *h, unsigned char *buf, int size)
+{
+    JSFetchContext *ctx = h->priv_data;
+    return jsfetch_read_js(ctx->idx, buf, size);
+}
+
+/**
+ * Close a fetch connection (JavaScript side).
+ */
+EM_JS(void, jsfetch_close_js, (int idx), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    if (jsfo) {
+        try { jsfo.reader.cancel(); } catch (ex) {}
+        delete Module.libavjsJSFetch.fetches[idx];
+    }
+});
+
+/**
+ * Close a fetch connection.
+ */
+static int jsfetch_close(URLContext *h)
+{
+    JSFetchContext *ctx = h->priv_data;
+    jsfetch_close_js(ctx->idx);
+    return 0;
+}
+
+const URLProtocol ff_jsfetch_protocol = {
+    .name               = "jsfetch",
+    .url_open2          = jsfetch_open,
+    .url_read           = jsfetch_read,
+    .url_close          = jsfetch_close,
+    .priv_data_size     = sizeof(JSFetchContext),
+    .priv_data_class    = &jsfetch_context_class,
+    .flags              = URL_PROTOCOL_FLAG_NETWORK,
+    .default_whitelist  = "jsfetch,http,https,crypto"
+};
+#endif
Index: ffmpeg-6.0.1/libavformat/protocols.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/protocols.c
+++ ffmpeg-6.0.1/libavformat/protocols.c
@@ -76,6 +76,10 @@ extern const URLProtocol ff_libzmq_proto
 extern const URLProtocol ff_ipfs_gateway_protocol;
 extern const URLProtocol ff_ipns_gateway_protocol;
 
+/* libav.js */
+extern const URLProtocol ff_jsfetch_protocol;
+/* /libav.js */
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)

Index: ffmpeg-6.0.1/libavformat/mov.c
===================================================================
From https://trac.ffmpeg.org/ticket/7359
https://github.com/FFmpeg/FFmpeg/commit/380a518c439d4e5e3cf17b97e4a06259e8048f99
Note: this patch isn't in 7.1.1.
--- ffmpeg-6.0.1.orig/libavformat/mov.c
+++ ffmpeg-6.0.1/libavformat/mov.c
@@ -10416,15 +10416,15 @@ static int mov_switch_root(AVFormatContext *s, int64_t target, int index)
 
     if (index >= 0 && index < mov->frag_index.nb_items)
         target = mov->frag_index.item[index].moof_offset;
-    if (avio_seek(s->pb, target, SEEK_SET) != target) {
+    if (target >= 0 && avio_seek(s->pb, target, SEEK_SET) != target) {
         av_log(mov->fc, AV_LOG_ERROR, "root atom offset 0x%"PRIx64": partial file\n", target);
         return AVERROR_INVALIDDATA;
     }
 
     mov->next_root_atom = 0;
-    if (index < 0 || index >= mov->frag_index.nb_items)
+    if ((index < 0 && target >= 0) || index >= mov->frag_index.nb_items)
         index = search_frag_moof_offset(&mov->frag_index, target);
-    if (index < mov->frag_index.nb_items &&
+    if (index >= 0 && index < mov->frag_index.nb_items &&
         mov->frag_index.item[index].moof_offset == target) {
         if (index + 1 < mov->frag_index.nb_items)
             mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;
@@ -10554,10 +10554,43 @@ static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
     MOVStreamContext *sc;
     AVIndexEntry *sample;
     AVStream *st = NULL;
+    FFStream *avsti = NULL;
     int64_t current_index;
     int ret;
+    int i;
     mov->fc = s;
  retry:
+        if (s->pb->pos == 0) {
+
+        // Discard current fragment index
+        if (mov->frag_index.allocated_size > 0) {
+            av_freep(&mov->frag_index.item);
+            mov->frag_index.nb_items = 0;
+            mov->frag_index.allocated_size = 0;
+            mov->frag_index.current = -1;
+            mov->frag_index.complete = 0;
+        }
+
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *avst = s->streams[i];
+            MOVStreamContext *msc = avst->priv_data;
+
+            // Clear current sample
+            mov_current_sample_set(msc, 0);
+            msc->ctts_index = 0;
+
+            // Discard current index entries
+            avsti = ffstream(avst);
+            if (avsti->index_entries_allocated_size > 0) {
+                av_freep(&avsti->index_entries);
+                avsti->index_entries_allocated_size = 0;
+                avsti->nb_index_entries = 0;
+            }
+        }
+
+        if ((ret = mov_switch_root(s, -1, -1)) < 0)
+            return ret;
+    }
     sample = mov_find_next_sample(s, &st);
     if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {
         if (!mov->next_root_atom)