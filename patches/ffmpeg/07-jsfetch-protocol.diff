Index: ffmpeg-6.0.1/libavformat/Makefile
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/Makefile
+++ ffmpeg-6.0.1/libavformat/Makefile
@@ -691,6 +691,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)
 OBJS-$(CONFIG_UDPLITE_PROTOCOL)          += udp.o ip.o
 OBJS-$(CONFIG_UNIX_PROTOCOL)             += unix.o
 
+# libav.js
+OBJS-$(CONFIG_JSFETCH_PROTOCOL)          += jsfetch.o
+# /libav.js
+
 # external library protocols
 OBJS-$(CONFIG_LIBAMQP_PROTOCOL)          += libamqp.o urldecode.o
 OBJS-$(CONFIG_LIBRIST_PROTOCOL)          += librist.o
Index: ffmpeg-6.0.1/libavformat/hls.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/hls.c
+++ ffmpeg-6.0.1/libavformat/hls.c
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -311,6 +311,36 @@ static void free_rendition_list(HLSContext *c)
     c->n_renditions = 0;
 }
 
+// When the M3U8 contains any absolute URIs - i.e init segment, AES key, or just normal segments,
+// the jsfetch: protocol needs to be prepended.
+static int jsfetch_wrap_url(const char *url, char **out_url)
+{
+    char *url_fixed = NULL;
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        url_fixed = av_malloc(strlen("jsfetch:") + strlen(url) + 1);
+        if (!url_fixed)
+            return AVERROR(ENOMEM);
+        strcpy(url_fixed, "jsfetch:");
+        strcat(url_fixed, url);
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *url_tail = url + strlen("crypto+");
+        url_fixed = av_malloc(strlen("crypto+jsfetch:") + strlen(url_tail) + 1);
+        if (!url_fixed)
+            return AVERROR(ENOMEM);
+        strcpy(url_fixed, "crypto+jsfetch:");
+        strcat(url_fixed, url_tail);
+    } else {
+        // No transformation needed; just duplicate original URL
+        url_fixed = av_strdup(url);
+        if (!url_fixed)
+            return AVERROR(ENOMEM);
+    }
+
+    *out_url = url_fixed;
+    return 0;
+}
+
 static struct playlist *new_playlist(HLSContext *c, const char *url,
                                      const char *base)
 {
@@ -438,7 +468,14 @@ static struct segment *new_init_section(struct playlist *pls,
             return NULL;
         }
     }
-    sec->url = av_strdup(ptr);
+    char *wrapped_url = NULL;
+    int ret = jsfetch_wrap_url(ptr, &wrapped_url);
+    if (ret < 0) {
+        sec->url = av_strdup(ptr);
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+    } else {
+        sec->url = av_strdup(wrapped_url);
+    }
     if (!sec->url) {
         av_free(sec);
         return NULL;
@@ -680,6 +717,8 @@ static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -981,7 +1020,14 @@ static int parse_playlist(HLSContext *c, const char *url,
                     av_free(seg);
                     goto fail;
                 }
-                seg->url = av_strdup(tmp_str);
+                char *wrapped_url = NULL;
+                int ret = jsfetch_wrap_url(tmp_str, &wrapped_url);
+                if (ret < 0) {
+                    seg->url = av_strdup(tmp_str);
+                    fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+                } else {
+                    seg->url = av_strdup(wrapped_url);
+                }
                 if (!seg->url) {
                     av_free(seg->key);
                     av_free(seg);
@@ -1294,6 +1340,16 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
+
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
     }
 
     av_log(pls->parent, AV_LOG_VERBOSE, "HLS request for url '%s', offset %"PRId64", playlist %d\n",
@@ -1348,14 +1404,15 @@ static int open_input(HLSContext *c, struct playlist *pls, struct segment *seg,
      * as would be expected. Wrong offset received from the server will not be
      * noticed without the call, though.
      */
-    if (ret == 0 && !is_http && seg->url_offset) {
-        int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
-        if (seekret < 0) {
-            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
-            ret = seekret;
-            ff_format_io_close(pls->parent, in);
-        }
-    }
+    // Breaks seeking on M3U8s containing byte ranges. Not needed for "http" anyways.
+    // if (ret == 0 && !is_http && seg->url_offset) {
+    //     int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
+    //     if (seekret < 0) {
+    //         av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
+    //         ret = seekret;
+    //         ff_format_io_close(pls->parent, in);
+    //     }
+    // }
 
 cleanup:
     av_dict_free(&opts);
 Index: ffmpeg-6.0.1/libavformat/jsfetch.c
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.c
@@ -0,0 +1,194 @@
+/*
+ * JavaScript fetch metaprotocol for ffmpeg client
+ * Copyright (c) 2023 Yahweasel and contributors
+ *
+ * This file is part of FFmpeg in libav.js. The following license applies only
+ * to this file.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "libavutil/error.h"
+#include "libavutil/opt.h"
+
+#include "url.h"
+
+#include <emscripten.h>
+#include <errno.h>
+
+typedef struct JSFetchContext {
+    const AVClass *class;
+    // All of the real information is stored in a JavaScript structure
+    int idx;
+} JSFetchContext;
+
+static const AVOption options[] = {
+    { NULL }
+};
+#if CONFIG_JSFETCH_PROTOCOL
+static const AVClass jsfetch_context_class = {
+    .class_name = "jsfetch",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT
+};
+
+/**
+ * Open a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_open_js, (const char *url, char* range_header, bool has_range), {
+    return Asyncify.handleAsync(function() {
+        return Promise.all([]).then(function() {
+            url = UTF8ToString(url);
+            var headers = {};
+            if (has_range) {
+               var range = range_header ? UTF8ToString(range_header) : undefined;
+               headers.Range = range;
+            }
+            var fetchUrl = url.startsWith("jsfetch:") ? url.slice(8) : url;
+            return fetch(fetchUrl, { headers });
+        }).then(function(response) {
+            if (!Module.libavjsJSFetch)
+                Module.libavjsJSFetch = {ctr: 1, fetches: {}};
+            var jsf = Module.libavjsJSFetch;
+            var idx = jsf.ctr++;
+            var reader = response.body.getReader();
+            var jsfo = jsf.fetches[idx] = {
+                url: url,
+                response: response,
+                reader: reader,
+                next: reader.read().then(function(res) {
+                    jsfo.buf = res;
+                }).catch(function(rej) {
+                    jsfo.rej = rej;
+                }),
+                buf: null,
+                rej: null
+            };
+            return idx;
+        }).catch(function(ex) {
+            Module.fsThrownError = ex;
+            console.error(ex);
+            return -11 /* ECANCELED */;
+        });
+    });
+});
+
+/**
+ * Open a fetch connection.
+ */
+static int jsfetch_open(URLContext *h, const char *url, int flags, AVDictionary **options)
+{
+    JSFetchContext *ctx = h->priv_data;
+    h->is_streamed = 1;
+
+    AVDictionaryEntry *entry = av_dict_get(*options, "range_header", NULL, 0);
+    const char *range_ptr = entry ? entry->value : NULL;
+    bool has_range = range_ptr != NULL;
+    ctx->idx = jsfetch_open_js(url, range_ptr, has_range);
+    return (ctx->idx > 0) ? 0 : ctx->idx;
+}
+
+/**
+ * Read from a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_read_js, (int idx, unsigned char *toBuf, int size), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    return Asyncify.handleAsync(function() { return Promise.all([]).then(function() {
+        if (jsfo.buf || jsfo.rej) {
+            // Already have data
+            var fromBuf = jsfo.buf;
+            var rej = jsfo.rej;
+
+            if (fromBuf) {
+                if (fromBuf.done) {
+                    // EOF
+                    return -0x20464f45 /* AVERROR_EOF */;
+                }
+                if (fromBuf.value.length > size) {
+                    // Return some of the buffer
+                    Module.HEAPU8.set(fromBuf.value.subarray(0, size), toBuf);
+                    fromBuf.value = fromBuf.value.subarray(size);
+                    return size;
+                }
+
+                /* Otherwise, return the remainder of the buffer and start
+                 * the next read */
+                var ret = fromBuf.value.length;
+                Module.HEAPU8.set(fromBuf.value, toBuf);
+                jsfo.buf = jsfo.rej = null;
+                jsfo.next = jsfo.reader.read().then(function(res) {
+                    jsfo.buf = res;
+                }).catch(function(rej) {
+                    jsfo.rej = rej;
+                });
+                return ret;
+            }
+
+            // Otherwise, there was an error
+            Module.fsThrownError = rej;
+            console.error(rej);
+            return -11 /* ECANCELED */;
+        }
+
+        // The next data isn't available yet. Force them to wait.
+        return Promise.race([
+            jsfo.next,
+            new Promise(function(res) { setTimeout(res, 100); })
+        ]).then(function() { return -6 /* EAGAIN */; });
+    }); });
+});
+
+/**
+ * Read from a fetch connection.
+ */
+static int jsfetch_read(URLContext *h, unsigned char *buf, int size)
+{
+    JSFetchContext *ctx = h->priv_data;
+    return jsfetch_read_js(ctx->idx, buf, size);
+}
+
+/**
+ * Close a fetch connection (JavaScript side).
+ */
+EM_JS(void, jsfetch_close_js, (int idx), {
+    var jsfo = Module.libavjsJSFetch.fetches[idx];
+    if (jsfo) {
+        try { jsfo.reader.cancel(); } catch (ex) {}
+        delete Module.libavjsJSFetch.fetches[idx];
+    }
+});
+
+/**
+ * Close a fetch connection.
+ */
+static int jsfetch_close(URLContext *h)
+{
+    JSFetchContext *ctx = h->priv_data;
+    jsfetch_close_js(ctx->idx);
+    return 0;
+}
+
+const URLProtocol ff_jsfetch_protocol = {
+    .name               = "jsfetch",
+    .url_open2          = jsfetch_open,
+    .url_read           = jsfetch_read,
+    .url_close          = jsfetch_close,
+    .priv_data_size     = sizeof(JSFetchContext),
+    .priv_data_class    = &jsfetch_context_class,
+    .flags              = URL_PROTOCOL_FLAG_NETWORK,
+    .default_whitelist  = "jsfetch,http,https,crypto"
+};
+#endif
Index: ffmpeg-6.0.1/libavformat/protocols.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/protocols.c
+++ ffmpeg-6.0.1/libavformat/protocols.c
@@ -76,6 +76,10 @@ extern const URLProtocol ff_libzmq_proto
 extern const URLProtocol ff_ipfs_gateway_protocol;
 extern const URLProtocol ff_ipns_gateway_protocol;
 
+/* libav.js */
+extern const URLProtocol ff_jsfetch_protocol;
+/* /libav.js */
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)

Index: ffmpeg-6.0.1/libavformat/mov.c
===================================================================
From https://trac.ffmpeg.org/ticket/7359
https://github.com/FFmpeg/FFmpeg/commit/380a518c439d4e5e3cf17b97e4a06259e8048f99
Note: this patch isn't in 7.1.1.
--- ffmpeg-6.0.1.orig/libavformat/mov.c
+++ ffmpeg-6.0.1/libavformat/mov.c
@@ -10416,15 +10416,15 @@ static int mov_switch_root(AVFormatContext *s, int64_t target, int index)
 
     if (index >= 0 && index < mov->frag_index.nb_items)
         target = mov->frag_index.item[index].moof_offset;
-    if (avio_seek(s->pb, target, SEEK_SET) != target) {
+    if (target >= 0 && avio_seek(s->pb, target, SEEK_SET) != target) {
         av_log(mov->fc, AV_LOG_ERROR, "root atom offset 0x%"PRIx64": partial file\n", target);
         return AVERROR_INVALIDDATA;
     }
 
     mov->next_root_atom = 0;
-    if (index < 0 || index >= mov->frag_index.nb_items)
+    if ((index < 0 && target >= 0) || index >= mov->frag_index.nb_items)
         index = search_frag_moof_offset(&mov->frag_index, target);
-    if (index < mov->frag_index.nb_items &&
+    if (index >= 0 && index < mov->frag_index.nb_items &&
         mov->frag_index.item[index].moof_offset == target) {
         if (index + 1 < mov->frag_index.nb_items)
             mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;
@@ -10554,10 +10554,43 @@ static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
     MOVStreamContext *sc;
     AVIndexEntry *sample;
     AVStream *st = NULL;
+    FFStream *avsti = NULL;
     int64_t current_index;
     int ret;
+    int i;
     mov->fc = s;
  retry:
+        if (s->pb->pos == 0) {
+
+        // Discard current fragment index
+        if (mov->frag_index.allocated_size > 0) {
+            av_freep(&mov->frag_index.item);
+            mov->frag_index.nb_items = 0;
+            mov->frag_index.allocated_size = 0;
+            mov->frag_index.current = -1;
+            mov->frag_index.complete = 0;
+        }
+
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *avst = s->streams[i];
+            MOVStreamContext *msc = avst->priv_data;
+
+            // Clear current sample
+            mov_current_sample_set(msc, 0);
+            msc->ctts_index = 0;
+
+            // Discard current index entries
+            avsti = ffstream(avst);
+            if (avsti->index_entries_allocated_size > 0) {
+                av_freep(&avsti->index_entries);
+                avsti->index_entries_allocated_size = 0;
+                avsti->nb_index_entries = 0;
+            }
+        }
+
+        if ((ret = mov_switch_root(s, -1, -1)) < 0)
+            return ret;
+    }
     sample = mov_find_next_sample(s, &st);
     if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {
         if (!mov->next_root_atom)