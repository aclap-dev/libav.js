Index: ffmpeg-6.0.1/libavformat/Makefile
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/Makefile
+++ ffmpeg-6.0.1/libavformat/Makefile
@@ -691,6 +691,10 @@ OBJS-$(CONFIG_UDP_PROTOCOL)
 OBJS-$(CONFIG_UDPLITE_PROTOCOL)          += udp.o ip.o
 OBJS-$(CONFIG_UNIX_PROTOCOL)             += unix.o
 
+# libav.js
+OBJS-$(CONFIG_JSFETCH_PROTOCOL)          += jsfetch.o
+# /libav.js
+
 # external library protocols
 OBJS-$(CONFIG_LIBAMQP_PROTOCOL)          += libamqp.o urldecode.o
 OBJS-$(CONFIG_LIBRIST_PROTOCOL)          += librist.o
Index: ffmpeg-6.0.1/libavformat/dashdec.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/dashdec.c
+++ ffmpeg-6.0.1/libavformat/dashdec.c
@@ -31,6 +31,7 @@
 #include "dash.h"
 #include "demux.h"
 #include "url.h"
+#include "jsfetch.h"
 
 #define INITIAL_BUFFER_SIZE 32768
 
@@ -401,6 +402,42 @@
     c->n_subtitles = 0;
 }
 
+static int jsfetch_wrap_url(const char *url, char *out_url)
+{
+    // Ensure the output buffer is always null-terminated initially
+    // to prevent issues with string functions like strncat.
+    out_url[0] = '\0';
+    size_t url_len = strlen(url);
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        const char *prefix = "jsfetch:";
+        size_t prefix_len = strlen(prefix);
+
+        strcpy(out_url, prefix);
+        strcat(out_url, url);
+
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *base_prefix = "crypto+";
+        size_t base_prefix_len = strlen(base_prefix);
+        const char *jsfetch_prefix = "jsfetch:";
+        size_t jsfetch_prefix_len = strlen(jsfetch_prefix);
+
+        // Calculate the tail of the URL (after "crypto+")
+        const char *url_tail = url + base_prefix_len;
+        size_t url_tail_len = strlen(url_tail);
+
+        strcpy(out_url, base_prefix);
+        strcat(out_url, jsfetch_prefix);
+        strcat(out_url, url_tail);
+
+    } else {
+        // No transformation needed; just copy original URL
+        strcpy(out_url, url);
+    }
+
+    return 0;
+}
+
 static int open_url(AVFormatContext *s, AVIOContext **pb, const char *url,
                     AVDictionary **opts, AVDictionary *opts2, int *is_http)
 {
@@ -418,6 +455,9 @@
     if (!proto_name)
         proto_name = avio_find_protocol_name(url);
 
+    av_log(NULL, AV_LOG_DEBUG, url);
+    av_log(NULL, AV_LOG_DEBUG, proto_name);
+
     if (!proto_name)
         return AVERROR_INVALIDDATA;
 
@@ -433,6 +473,8 @@
         }
     } else if (av_strstart(proto_name, "http", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -515,8 +557,17 @@
         }
     }
 end:
-    av_free(tmp_str);
-    return url;
+    // Longest is with crypto:jsfetch: prepended
+    char wrapped_url[MAX_URL_SIZE + 15];
+    int ret = jsfetch_wrap_url(url, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        return NULL;
+    }
+    av_free(url);
+    return av_strdup(wrapped_url);
+    // av_free(tmp_str);
+    // return url;
 }
 
 static char *get_val_from_nodes_tab(xmlNodePtr *nodes, const int n_nodes, const char *attrname)
@@ -805,8 +856,11 @@
                 memset(p + 1, 0, strlen(p));
             }
             av_strlcat(tmp_str, text + start, tmp_max_url_size);
-            xmlNodeSetContent(baseurl_nodes[i], tmp_str);
+            // https://trac.ffmpeg.org/ticket/7395
+            xmlChar *escaped = xmlEncodeSpecialChars(NULL, tmp_str);
+            xmlNodeSetContent(baseurl_nodes[i], escaped);
             updated = 1;
+            xmlFree(escaped);
             xmlFree(text);
         }
     }
@@ -1590,7 +1644,7 @@
     struct fragment *seg_ptr = NULL;
     DASHContext *c = pls->parent->priv_data;
 
-    while (( !ff_check_interrupt(c->interrupt_callback)&& pls->n_fragments > 0)) {
+    while (( !ff_check_interrupt(c->interrupt_callback) && !jsfetch_already_aborted() && pls->n_fragments > 0)) {
         if (pls->cur_seq_no < pls->n_fragments) {
             seg_ptr = pls->fragments[pls->cur_seq_no];
             seg = av_mallocz(sizeof(struct fragment));
@@ -1687,7 +1741,12 @@
     char *url = NULL;
     int ret = 0;
 
+    // Longest is with crypto:jsfetch: prepended
+    // Can't put it later due to goto.
+    char wrapped_url[MAX_URL_SIZE + 15];
+
     url = av_mallocz(c->max_url_size);
+
     if (!url) {
         ret = AVERROR(ENOMEM);
         goto cleanup;
@@ -1698,9 +1757,31 @@
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
+
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
+        
+        av_log(NULL, AV_LOG_DEBUG, range_header);
     }
+    // Custom value used by us in jsfetch to prevent unnecessary seeking
+    av_dict_set_int(&opts, "jsfetch_skip_seek", 1, 0);
 
     ff_make_absolute_url(url, c->max_url_size, c->base_url, seg->url);
+    ret = jsfetch_wrap_url(url, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        goto cleanup;
+    } else {
+        av_free(url);
+        url = av_strdup(wrapped_url);
+    }
     av_log(pls->parent, AV_LOG_VERBOSE, "DASH request for url '%s', offset %"PRId64"\n",
            url, seg->url_offset);
     ret = open_url(pls->parent, &pls->input, url, &c->avio_opts, opts, NULL);
@@ -1791,7 +1872,7 @@
 
         ret = open_input(c, v, v->cur_seg);
         if (ret < 0) {
-            if (ff_check_interrupt(c->interrupt_callback)) {
+            if (ff_check_interrupt(c->interrupt_callback) || jsfetch_already_aborted()) {
                 ret = AVERROR_EXIT;
                 goto end;
             }
@@ -1863,7 +1944,7 @@
         close_demux_for_component(pls);
     }
 
-    if (ff_check_interrupt(&s->interrupt_callback)) {
+    if (ff_check_interrupt(&s->interrupt_callback) || jsfetch_already_aborted()) {
         ret = AVERROR_EXIT;
         goto fail;
     }
@@ -1880,8 +1961,10 @@
         pls->ctx = NULL;
         goto fail;
     }
+    // Disable/hide seeking (last arg).
+    // We implement a seek within individual segments but not for the whole playlist.
     ffio_init_context(&pls->pb, avio_ctx_buffer, INITIAL_BUFFER_SIZE, 0,
-                      pls, read_data, NULL, c->is_live ? NULL : seek_data);
+                      pls, read_data, NULL, NULL);
     pls->pb.pub.seekable = 0;
 
     if ((ret = ff_copy_whiteblacklists(pls->ctx, s)) < 0)
@@ -2197,7 +2280,7 @@
     if (!cur) {
         return AVERROR_INVALIDDATA;
     }
-    while (!ff_check_interrupt(c->interrupt_callback) && !ret) {
+    while (!ff_check_interrupt(c->interrupt_callback) && !jsfetch_already_aborted() && !ret) {
         ret = av_read_frame(cur->ctx, pkt);
         if (ret >= 0) {
             /* If we got a packet, return it */
Index: ffmpeg-6.0.1/libavformat/hls.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/hls.c
+++ ffmpeg-6.0.1/libavformat/hls.c
@@ -47,6 +47,9 @@
 #include "url.h"
 
 #include "hls_sample_encryption.h"
+#include "jsfetch.h"
+#include <emscripten.h>
+#include <math.h>
 
 #define INITIAL_BUFFER_SIZE 32768
 
@@ -311,6 +314,44 @@
     c->n_renditions = 0;
 }
 
+// When the M3U8 contains any absolute URIs - i.e init segment, AES key, or just normal segments,
+// the jsfetch: protocol needs to be prepended.
+static int jsfetch_wrap_url(const char *url, char *out_url)
+{
+    // Ensure the output buffer is always null-terminated initially
+    // to prevent issues with string functions like strncat.
+    out_url[0] = '\0';
+    size_t url_len = strlen(url);
+
+    if (av_strstart(url, "http://", NULL) || av_strstart(url, "https://", NULL)) {
+        const char *prefix = "jsfetch:";
+        size_t prefix_len = strlen(prefix);
+
+        strcpy(out_url, prefix);
+        strcat(out_url, url);
+
+    } else if (av_strstart(url, "crypto+http://", NULL) || av_strstart(url, "crypto+https://", NULL)) {
+        const char *base_prefix = "crypto+";
+        size_t base_prefix_len = strlen(base_prefix);
+        const char *jsfetch_prefix = "jsfetch:";
+        size_t jsfetch_prefix_len = strlen(jsfetch_prefix);
+
+        // Calculate the tail of the URL (after "crypto+")
+        const char *url_tail = url + base_prefix_len;
+        size_t url_tail_len = strlen(url_tail);
+
+        strcpy(out_url, base_prefix);
+        strcat(out_url, jsfetch_prefix);
+        strcat(out_url, url_tail);
+
+    } else {
+        // No transformation needed; just copy original URL
+        strcpy(out_url, url);
+    }
+
+    return 0;
+}
+
 static struct playlist *new_playlist(HLSContext *c, const char *url,
                                      const char *base)
 {
@@ -438,7 +479,16 @@
             return NULL;
         }
     }
-    sec->url = av_strdup(ptr);
+    // Longest is with crypto:jsfetch: prepended
+    char wrapped_url[MAX_URL_SIZE + 15];
+    int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+    if (ret < 0) {
+        fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+        av_free(sec);
+        return NULL;
+    } else {
+        sec->url = av_strdup(wrapped_url);
+    }
     if (!sec->url) {
         av_free(sec);
         return NULL;
@@ -680,6 +730,8 @@
         is_http = 1;
     } else if (av_strstart(proto_name, "data", NULL)) {
         ;
+    } else if (av_strstart(proto_name, "jsfetch", NULL)) {
+        ;
     } else
         return AVERROR_INVALIDDATA;
 
@@ -956,14 +1008,18 @@
                     AV_WB64(seg->iv + 8, seq);
                 }
 
+                // Longest is with crypto:jsfetch: prepended
+                char wrapped_url[MAX_URL_SIZE + 15];
+
                 if (key_type != KEY_NONE) {
                     ff_make_absolute_url(tmp_str, sizeof(tmp_str), url, key);
-                    if (!tmp_str[0]) {
+                    int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+                    if (ret < 0) {
                         ret = AVERROR_INVALIDDATA;
                         av_free(seg);
                         goto fail;
                     }
-                    seg->key = av_strdup(tmp_str);
+                    seg->key = av_strdup(wrapped_url);
                     if (!seg->key) {
                         av_free(seg);
                         ret = AVERROR(ENOMEM);
@@ -981,7 +1037,14 @@
                     av_free(seg);
                     goto fail;
                 }
-                seg->url = av_strdup(tmp_str);
+                int ret = jsfetch_wrap_url(tmp_str, wrapped_url);
+                if (ret < 0) {
+                    fprintf(stderr, "Failed to wrap URL: %s\n", av_err2str(ret));
+                    av_free(seg);
+                    goto fail;
+                } else {
+                    seg->url = av_strdup(wrapped_url);
+                }
                 if (!seg->url) {
                     av_free(seg->key);
                     av_free(seg);
@@ -1294,8 +1357,17 @@
          * (if this is in fact a HTTP request) */
         av_dict_set_int(&opts, "offset", seg->url_offset, 0);
         av_dict_set_int(&opts, "end_offset", seg->url_offset + seg->size, 0);
-    }
 
+        // Pre-populate the byte range header if needed. Passed to jsfetch in AVDictionary.
+        char range_header[128] = {0};
+        if (seg->url_offset >= 0 && seg->size > 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-%" PRId64, seg->url_offset, seg->url_offset + seg->size - 1);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        } else if (seg->url_offset >= 0) {
+            snprintf(range_header, sizeof(range_header), "bytes=%" PRId64 "-", seg->url_offset);
+            av_dict_set(&opts, "range_header", range_header, 0);
+        }
+      }
     av_log(pls->parent, AV_LOG_VERBOSE, "HLS request for url '%s', offset %"PRId64", playlist %d\n",
            seg->url, seg->url_offset, pls->index);
 
@@ -1348,14 +1420,15 @@
      * as would be expected. Wrong offset received from the server will not be
      * noticed without the call, though.
      */
-    if (ret == 0 && !is_http && seg->url_offset) {
-        int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
-        if (seekret < 0) {
-            av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
-            ret = seekret;
-            ff_format_io_close(pls->parent, in);
-        }
-    }
+    // Breaks seeking on M3U8s containing byte ranges. Not needed for "http" anyways.
+    // if (ret == 0 && !is_http && seg->url_offset) {
+    //     int64_t seekret = avio_seek(*in, seg->url_offset, SEEK_SET);
+    //     if (seekret < 0) {
+    //         av_log(pls->parent, AV_LOG_ERROR, "Unable to seek to offset %"PRId64" of HLS segment '%s'\n", seg->url_offset, seg->url);
+    //         ret = seekret;
+    //         ff_format_io_close(pls->parent, in);
+    //     }
+    // }
 
 cleanup:
     av_dict_free(&opts);
@@ -1542,9 +1615,9 @@
             if (v->finished)
                 return AVERROR_EOF;
             while (av_gettime_relative() - v->last_load_time < reload_interval) {
-                if (ff_check_interrupt(c->interrupt_callback))
+                if (ff_check_interrupt(c->interrupt_callback) || jsfetch_already_aborted())
                     return AVERROR_EXIT;
-                av_usleep(100*1000);
+                emscripten_sleep(100);
             }
             /* Enough time has elapsed since the last reload */
             goto reload;
@@ -1567,7 +1640,7 @@
             ret = open_input(c, v, seg, &v->input);
         }
         if (ret < 0) {
-            if (ff_check_interrupt(c->interrupt_callback))
+            if (ff_check_interrupt(c->interrupt_callback) || jsfetch_already_aborted())
                 return AVERROR_EXIT;
             av_log(v->parent, AV_LOG_WARNING, "Failed to open segment %"PRId64" of playlist %d\n",
                    v->cur_seq_no,
@@ -1601,7 +1674,7 @@
         seg && seg->key_type == KEY_NONE && av_strstart(seg->url, "http", NULL)) {
         ret = open_input(c, v, seg, &v->input_next);
         if (ret < 0) {
-            if (ff_check_interrupt(c->interrupt_callback))
+            if (ff_check_interrupt(c->interrupt_callback) || jsfetch_already_aborted())
                 return AVERROR_EXIT;
             av_log(v->parent, AV_LOG_WARNING, "Failed to open segment %"PRId64" of playlist %d\n",
                    v->cur_seq_no + 1,
@@ -2540,25 +2613,27 @@
         strstr(p->buf, "#EXT-X-TARGETDURATION:") ||
         strstr(p->buf, "#EXT-X-MEDIA-SEQUENCE:")) {
 
-        int mime_ok = p->mime_type && !(
-            av_strcasecmp(p->mime_type, "application/vnd.apple.mpegurl") &&
-            av_strcasecmp(p->mime_type, "audio/mpegurl")
-            );
-
-        int mime_x = p->mime_type && !(
-            av_strcasecmp(p->mime_type, "audio/x-mpegurl") &&
-            av_strcasecmp(p->mime_type, "application/x-mpegurl")
-            );
-
-        if (!mime_ok &&
-            !mime_x &&
-            !av_match_ext    (p->filename, "m3u8,m3u") &&
-             ff_match_url_ext(p->filename, "m3u8,m3u") <= 0) {
-            av_log(NULL, AV_LOG_ERROR, "Not detecting m3u8/hls with non standard extension and non standard mime type\n");
-            return 0;
-        }
-        if (mime_x)
-            av_log(NULL, AV_LOG_WARNING, "mime type is not rfc8216 compliant\n");
+        // Don't worry about MIME type. Close enough if it has the above.
+
+        // int mime_ok = p->mime_type && !(
+        //     av_strcasecmp(p->mime_type, "application/vnd.apple.mpegurl") &&
+        //     av_strcasecmp(p->mime_type, "audio/mpegurl")
+        //     );
+
+        // int mime_x = p->mime_type && !(
+        //     av_strcasecmp(p->mime_type, "audio/x-mpegurl") &&
+        //     av_strcasecmp(p->mime_type, "application/x-mpegurl")
+        //     );
+
+        // if (!mime_ok &&
+        //     !mime_x &&
+        //     !av_match_ext    (p->filename, "m3u8,m3u") &&
+        //      ff_match_url_ext(p->filename, "m3u8,m3u") <= 0) {
+        //     av_log(NULL, AV_LOG_ERROR, "Not detecting m3u8/hls with non standard extension and non standard mime type\n");
+        //     return 0;
+        // }
+        // if (mime_x)
+        //     av_log(NULL, AV_LOG_WARNING, "mime type is not rfc8216 compliant\n");
 
         return AVPROBE_SCORE_MAX;
     }
 Index: ffmpeg-6.0.1/libavformat/url.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/url.c
+++ ffmpeg-6.0.1/libavformat/url.c
--- a/libavformat/url.c
+++ b/libavformat/url.c
@@ -201,6 +201,11 @@ int ff_make_absolute_url2(char *buf, int size, const char *base,
     int use_base_path, simplify_path = 0, ret;
     const char *base_separators = "/";
 
+    // Adjust base pointer to skip "jsfetch:" if exists
+    if (av_strstart(base, "jsfetch:", NULL)) {
+        base = base + 8; 
+    }
+
     /* This is tricky.
        For HTTP, http://server/site/page + ../media/file
        should resolve into http://server/media/file

 Index: ffmpeg-6.0.1/libavformat/jsfetch.h
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.h
@@ -0,0 +1,11 @@
+#ifndef JSFETCH_H
+#define JSFETCH_H
+
+void jsfetch_abort_request(void);
+int jsfetch_get_return_code(void);
+void jsfetch_set_read_timeout(int ms);
+void jsfetch_set_fetch_timeout(int ms);
+void jsfetch_set_initial_retry_delay(int ms);
+int jsfetch_already_aborted(void);
+
+#endif
 Index: ffmpeg-6.0.1/libavformat/jsfetch.c
===================================================================
--- /dev/null
+++ ffmpeg-6.0.1/libavformat/jsfetch.c
@@ -0,0 +1,554 @@
+/*
+ * JavaScript fetch metaprotocol for ffmpeg client
+ * Copyright (c) 2023 Yahweasel and contributors
+ *
+ * This file is part of FFmpeg in libav.js. The following license applies only
+ * to this file.
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include "config.h"
+#include "config_components.h"
+
+#include "libavutil/error.h"
+#include "libavutil/opt.h"
+
+#include "url.h"
+#include "jsfetch.h"
+
+#include <emscripten.h>
+#include <errno.h>
+
+typedef struct JSFetchContext {
+    const AVClass *class;
+    // All of the real information is stored in a JavaScript structure
+    int idx;
+} JSFetchContext;
+
+static const AVOption options[] = {
+    { NULL }
+};
+static volatile int jsfetch_aborted = 0;
+
+#define CONFIG_JSFETCH_PROTOCOL 1
+#if CONFIG_JSFETCH_PROTOCOL
+static const AVClass jsfetch_context_class = {
+    .class_name = "jsfetch",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT
+};
+
+/**
+ * Initialize functions.
+ * See pre.js for other initialized functions.
+ */
+EM_JS(void, jsfetch_init, (), {
+  if (Module.initialized) {
+    return;
+  }
+  Module.MAX_FETCH_ATTEMPTS = 6;
+  Module.MAX_READ_ATTEMPTS = 6;
+  Module.MAX_SIZE_TO_SKIP_ON_READ_FAILURE = 41943040; // 40 MB
+  
+  // Maybe set below during testing.
+  Module.FETCH_TIMEOUT = Module.FETCH_TIMEOUT || 30 * 1000;
+  Module.READ_TIMEOUT = Module.READ_TIMEOUT || 30 * 1000;
+  Module.INITIAL_RETRY_DELAY = Module.INITIAL_RETRY_DELAY || 250;
+
+  Module.libavjsJSFetch = { ctr: 1, fetches: {}, pos: 0, read_failures: 0 };
+  Module.abortController = new AbortController();
+  Module.readFailureMap = new Map();
+
+  Module.initialized = true;
+});
+
+/**
+ * Set timeouts - for testing only.
+ */
+EM_JS(void, jsfetch_set_fetch_timeout_js, (int ms), {
+  Module.FETCH_TIMEOUT = ms;
+});
+
+void jsfetch_set_fetch_timeout(int ms) {
+  return jsfetch_set_fetch_timeout_js(ms);
+}
+
+EM_JS(void, jsfetch_set_read_timeout_js, (int ms), {
+  Module.READ_TIMEOUT = ms;
+});
+
+void jsfetch_set_read_timeout(int ms) {
+  return jsfetch_set_read_timeout_js(ms);
+}
+
+EM_JS(void, jsfetch_set_initial_retry_delay_js, (int ms), {
+  Module.INITIAL_RETRY_DELAY = ms;
+});
+
+void jsfetch_set_initial_retry_delay(int ms) {
+  return jsfetch_set_initial_retry_delay_js(ms);
+}
+
+/**
+ * Get return code
+ * 
+ * 100-600:  Reserved for HTTP (i.e 403, 500)
+ * 1001:     Network Error
+ * 1002:     Read Error
+ * 1003:     Fetch timeout
+ */
+EM_JS(int, jsfetch_get_code, (), {
+  return Module.returnCode || 0;
+});
+
+int jsfetch_get_return_code() {
+  return jsfetch_get_code();
+}
+
+EM_JS(void, jsfetch_abort, (), {
+    var abortController = Module.abortController;
+    if (abortController) {
+        abortController.abort(`Download aborted by user`);
+    } else {
+      // Early-abort any fetches started after this.
+      Module.abortController = new AbortController();
+      Module.abortController.abort(`Download aborted by user`);
+    }
+});
+
+void jsfetch_abort_request(void) {
+  jsfetch_abort();
+  jsfetch_aborted = 1;
+}
+
+int jsfetch_already_aborted(void) {
+  return jsfetch_aborted;
+}
+
+// Used only by seek, to close the request without deleting the jsfo.
+// Mainly to preserve the total size.
+EM_JS(void, jsfetch_abort_individual, (int idx), {
+  const jsfo = Module.libavjsJSFetch.fetches[idx];
+  if (!jsfo) {
+    return;
+  }
+  jsfo.abortController.abort();
+});
+
+/**
+ * Open a fetch connection (JavaScript side).
+ * Must return an Asyncify.
+ */
+EM_JS(int, jsfetch_open_js, (const char* url, char* range_header, bool has_range, int force_idx, bool probe_range_support), {
+  return Asyncify.handleAsync(async function() {
+    if (Module.abortController.signal.aborted) {
+      console.warn("jsfetch_open_js aborted.");
+      return -0x54584945; /* AVERROR_EXIT*/
+    }
+
+    // Headers
+    let headers = {};
+    let range;
+    if (has_range) {
+      range = range_header ? UTF8ToString(range_header) : undefined;
+      headers.Range = range;
+    } else if (probe_range_support) {
+      headers.Range = 'bytes=0-';
+    }
+    
+    url = UTF8ToString(url);
+    const fetchUrl = url.startsWith("jsfetch:") ? url.slice(8) : url;
+
+    // Abort
+    const requestAbortController = new AbortController();
+    const combinedSignal = AbortSignal.any([requestAbortController.signal, Module.abortController.signal]);
+
+    // First, probe for range support. 
+    // No retries. We could get 416 (Range Not Satisfiable).
+    // The server could also reject it with another code or close it if they don't support ranges.
+    let response;
+    if (probe_range_support) {
+      response = await Module.FetchWithRetry(fetchUrl, headers, 1, Module.FETCH_TIMEOUT, Module.INITIAL_RETRY_DELAY, combinedSignal);
+      if (!response.ok) {
+        delete headers.Range;
+      }
+    }
+
+    // Not probing for range support, or the probe failed.
+    if (!probe_range_support || !response.ok) {
+      response = await Module.FetchWithRetry(fetchUrl, headers, Module.MAX_FETCH_ATTEMPTS, Module.FETCH_TIMEOUT, Module.INITIAL_RETRY_DELAY, combinedSignal);
+      if (response.aborted) {
+        return -0x54584945; /* AVERROR_EXIT*/
+      } else if (response.timeout) {
+        Module.returnCode = 1003; /* Fetch timeout*/
+        // Should return a partial file if we've downloaded anything so far.
+        return -0x20464f45 /* AVERROR_EOF */;
+      } else if (response instanceof Error) {
+        Module.returnCode = 1001; /* Network Error*/
+        return -0x20464f45 /* AVERROR_EOF */;
+      } else if (response.err_status) {
+        Module.returnCode = response.err_status;
+        return -0x20464f45 /* AVERROR_EOF */;
+      }
+    }
+    // ..Response is ok
+
+    const accept_range = (response.headers.get("accept-ranges") || "").toLowerCase();
+    const content_range = response.headers.get("content-range");
+    const support_range = (accept_range && accept_range == "bytes") || (response.status == 206 && content_range != undefined);
+
+    let total_size = 0;
+    if (content_range) {
+      // The extra \\d here is intentional, because this goes through C first. \\d -> \d
+      const match = content_range.match(/bytes \\\\d+-\\\\d+\\\\/(\\\\d+)/);
+      total_size = match ? parseInt(match[1]) : 0;
+    }
+
+    const idx = force_idx ? force_idx : Module.libavjsJSFetch.ctr++;
+    const reader = response.body.getReader();
+
+    combinedSignal.addEventListener('abort', async () => {
+      try { await reader.cancel(); } catch (e) { /* */};
+    });
+
+    // Extra \\d same as above
+    const pos = range ? Number(range.match(/bytes=(\\d+)/)?.[1] ?? 0) : 0;
+
+    var jsfo = Module.libavjsJSFetch.fetches[idx] = {
+      abortController: requestAbortController,
+      url,
+      response,
+      reader,
+      support_range,
+      total_size,
+      pos,
+      first_read: true,
+      buf: null,
+      rej: null,
+    };
+
+    return idx;
+  });
+});
+
+/**
+ * Check byte range support
+ */
+EM_JS(int, jsfetch_support_range_js, (int idx), {
+  const jsfo = Module.libavjsJSFetch.fetches[idx];
+  return jsfo && jsfo.support_range ? 1 : 0;
+});
+
+/**
+ * Check size
+ */
+EM_JS(double, jsfetch_get_size_js, (int idx), {
+  const jsfo = Module.libavjsJSFetch.fetches[idx];
+  return jsfo ? jsfo.total_size : 0;
+});
+
+/**
+ * Get curr position
+ */
+EM_JS(double, jsfetch_get_pos_js, (int idx), {
+  const jsfo = Module.libavjsJSFetch.fetches[idx];
+  return jsfo ? jsfo.pos : 0;
+});
+
+/**
+ * Open a fetch connection.
+ */
+static int jsfetch_open(URLContext *h, const char *url, int flags, AVDictionary **options)
+{
+    jsfetch_init();
+
+    JSFetchContext *ctx = h->priv_data;
+
+    AVDictionaryEntry *entry = av_dict_get(*options, "range_header", NULL, 0);
+    const char *range_ptr = entry ? entry->value : NULL;
+    bool has_range = range_ptr != NULL;
+
+    ctx->idx = jsfetch_open_js(url, range_ptr, has_range, 0, !has_range);
+
+    // Seek if range header is supported.
+    int support = jsfetch_support_range_js(ctx->idx);
+    h->is_streamed = (bool) !support;
+
+    return (ctx->idx > 0) ? 0 : ctx->idx;
+}
+
+/**
+ * Read from a fetch connection (JavaScript side).
+ */
+EM_JS(int, jsfetch_read_js, (int idx, unsigned char *toBuf, int size), {
+    return Asyncify.handleAsync(async function() {
+      const self = async function() {
+        var jsfo = Module.libavjsJSFetch.fetches[idx];
+        if (Module.abortController.signal.aborted || !jsfo) {
+          console.warn("jsfetch_read_js aborted.");
+          return -0x54584945; /* AVERROR_EXIT*/
+        }
+        try {
+          // Check for remainder
+          if (jsfo.buf && jsfo.buf.value && jsfo.buf.value.length > 0) {
+            const chunk = jsfo.buf.value;
+            const len = Math.min(size, chunk.length);
+
+            Module.HEAPU8.set(chunk.subarray(0, len), toBuf);
+            jsfo.buf.value = chunk.subarray(len);
+            if (jsfo.buf.value.length === 0) {
+              jsfo.buf = null;
+            }
+            jsfo.pos += len;
+            return len;
+          }
+          
+          // We may abort, timeout, or read successfully.
+          const timeout_p = Module.DoAbortableSleep(Module.READ_TIMEOUT, Module.abortController.signal);
+          const read_p = jsfo.reader.read();
+          const race_res = await Promise.race([timeout_p, read_p]);
+          
+          // Aborted / Timed out
+          if (race_res == "aborted") {
+            return -0x54584945; /* AVERROR_EXIT*/
+          } else if (race_res == "timed_out") {
+            await jsfo.reader.cancel();
+            throw `Timed out after ${Module.READ_TIMEOUT} ms.`;
+          }
+
+          if (race_res.done) {
+            return -0x20464f45 /* AVERROR_EOF */;
+          }
+
+          // Reset read failures
+          Module.libavjsJSFetch.read_failures = 0;
+
+          let chunk = race_res.value;
+
+          // Skip
+          const skip_bytes = Module.readFailureMap.get(idx);
+          if (skip_bytes > jsfo.pos) {
+            const bytes_to_skip = skip_bytes - jsfo.pos;
+            if (bytes_to_skip >= chunk.length) {
+              // Entire chunk is before our skip point - discard and fetch next
+              jsfo.pos += chunk.length;
+              return self();
+            } else {
+              // Partial skip
+              chunk = chunk.subarray(bytes_to_skip);
+              jsfo.pos += bytes_to_skip;
+              Module.readFailureMap.delete(idx);
+            }
+          }
+        
+          // Check for PNG in the first read only.
+          // Have to assume/hope the PNG is not split across reads.
+          // Otherwise this won't work.
+          if (jsfo.first_read) {
+            jsfo.first_read = false;
+            const png_index = Module.FindPngSliceIndex(chunk);
+            if (png_index >= 0) {
+              chunk = chunk.subarray(png_index);
+              jsfo.pos += png_index;
+            }
+          }
+          const len = Math.min(size, chunk.length);
+          Module.HEAPU8.set(chunk.subarray(0, len), toBuf);
+
+          // Save the remainder
+          if (chunk.length > len) {
+            jsfo.buf = {
+              value: chunk.subarray(len)
+            };
+          } else {
+            jsfo.buf = null;
+          }
+          jsfo.pos += len;
+
+          return len;
+        } catch (e) {
+          if (jsfo.abortController.signal.aborted || Module.abortController.signal.aborted) {
+            console.warn("jsfetch_read_js aborted.");
+            return -0x54584945; /* AVERROR_EXIT*/
+          }
+
+          console.warn("jsfetch_read_js error", e);
+          Module.libavjsJSFetch.read_failures++;
+
+          // Cannot retry
+          const too_big_to_retry_without_seek = jsfo.total_size > Module.MAX_SIZE_TO_SKIP_ON_READ_FAILURE;
+          if (Module.libavjsJSFetch.read_failures >= Module.MAX_READ_ATTEMPTS || (!jsfo.support_range && too_big_to_retry_without_seek)) {
+            console.warn(`Cant retry. read_failures: ${Module.libavjsJSFetch.read_failures}, too_big: ${too_big_to_retry_without_seek}`);
+            Module.returnCode = 1002; /* Read Error*/
+            
+            return -0x20464f45 /* AVERROR_EOF */;
+          }
+
+          const delay = Math.pow(2, Module.libavjsJSFetch.read_failures) * Module.INITIAL_RETRY_DELAY;
+          console.warn(`Retrying read in ${delay} ms`);
+          const combinedSignal = AbortSignal.any([jsfo.abortController.signal, Module.abortController.signal]);
+          const abort_or_timeout = await Module.DoAbortableSleep(delay, combinedSignal);
+          if (abort_or_timeout == "aborted") {
+            return -0x54584945; /* AVERROR_EXIT*/
+          }
+
+          // Retry without range support
+          if (!jsfo.support_range) {
+            console.warn(`Retrying without range support, will skip ${jsfo.pos} bytes`);
+            const existing = Module.readFailureMap.get(idx) || 0;
+            const skip_bytes = Math.max(existing, jsfo.pos);
+            Module.readFailureMap.set(idx, skip_bytes);
+            return -1001; // Signal retry without seek in jsfetch_read()
+          }
+
+          // Retry with range support
+          console.warn(`Retrying with range support from ${jsfo.pos}`);
+          return -1000; // Signals retry in jsfetch_read()
+        }
+      };
+    return self();
+  });
+});
+
+/**
+ * Close a fetch connection (JavaScript side).
+ */
+EM_JS(void, jsfetch_close_js, (int idx), {
+  var jsfo = Module.libavjsJSFetch.fetches[idx];
+  if (jsfo) {
+    jsfo.reader.cancel().catch((e) => { /* */});
+
+    delete Module.libavjsJSFetch.fetches[idx];
+  }
+});
+
+/**
+ * Close a fetch connection.
+ */
+static int jsfetch_close(URLContext *h)
+{
+  JSFetchContext *ctx = h->priv_data;
+  jsfetch_close_js(ctx->idx);
+  return 0;
+}
+
+// Note: Use double for size/pos. Otherwise we can overflow.
+// Works up to 2^53 bytes ~ 9PB, so should be fine.
+// EM_JS can't handle int64_t without the -sWASM_BIGINT build flag. 
+// Building with it might mess up ffmpeg function bindings that do int64_t => {lo, hi} conversion.
+// https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-pass-int64-t-and-uint64-t-values-from-js-into-wasm-functions
+static int64_t jsfetch_seek(URLContext *h, int64_t pos, int whence)
+{
+    av_log(h, AV_LOG_DEBUG, "[jsfetch] Seeking to pos=%" PRId64 ", whence=%d, url=%s\n",
+           pos, whence, h->filename);
+
+    JSFetchContext *ctx = h->priv_data;
+
+    if (h->is_streamed) {
+      av_log(h, AV_LOG_ERROR, "[jsfetch] Seek was called but not supported.\n");
+      return AVERROR(ENOSYS); 
+    }
+
+    // AVSEEK_SIZE - should return the size
+    int64_t size = (double) jsfetch_get_size_js(ctx->idx);
+    if (whence == 0x10000) {
+      return size ? size : -38;// AVERROR(ENOSYS)
+    }
+
+    // SEEK_CUR: Seek to curr + pos. Very unlikely.
+    if (whence == 1) {
+      double curr_pos = jsfetch_get_pos_js(ctx->idx);
+      pos += (int64_t) curr_pos;
+    }
+
+    // SEEK_END: Seek to end of stream + pos.
+    // Usually pos is -1.
+    if (whence == 2) {
+      pos += (int64_t) size;
+    }
+
+    jsfetch_abort_individual(ctx->idx);
+    int has_range = (pos >= 0);
+    char range_header_buf[128];
+    char *range_header = NULL;
+    if (has_range) {
+        // "bytes=<start>-"
+        snprintf(range_header_buf, sizeof(range_header_buf), "bytes=%" PRId64 "-", pos);
+        range_header = range_header_buf;
+    }
+
+    // Force the same idx
+    // NOTE: pos is set in jsfetch_open_js. 
+    // If SEEK_CUR is then called, jsfetch_get_pos_js works.
+    int ret = jsfetch_open_js(h->filename, range_header, has_range, ctx->idx, false);
+    if (ret < 0) {
+      return ret;
+    }
+
+    return pos;
+}
+
+/**
+ * Read from a fetch connection.
+ */
+static int jsfetch_read(URLContext *h, unsigned char *buf, int size)
+{
+    JSFetchContext *ctx = h->priv_data;
+    int ret = jsfetch_read_js(ctx->idx, buf, size);
+    // If retries are not possible / needed.
+    if (ret != -1000 && ret != -1001) {
+     return ret;
+    }
+    av_log(h, AV_LOG_ERROR, "[jsfetch] jsfetch_read retrying mode: %d\n", ret);
+
+    /* Retry with close/reopen */
+    if (ret == -1001) {
+      ret = jsfetch_close(h);
+       if (ret < 0) {
+        av_log(h, AV_LOG_ERROR, "[jsfetch] jsfetch_close failed with error %d\n", ret);
+        return ret;
+      }
+      // Force the same idx
+      ret = jsfetch_open_js(h->filename, NULL, false, ctx->idx, false);
+      if (ret < 0) {
+        return ret;
+      }
+      return jsfetch_read(h, buf, size);
+    }
+
+    /* Retry via seek */
+    // Get pos
+    int64_t pos = (int64_t) jsfetch_get_pos_js(ctx->idx);
+
+    // Seek
+    ret = jsfetch_seek(h, pos, 0);
+    if (ret < 0) {
+     return ret;
+    }
+
+    return jsfetch_read(h, buf, size);
+}
+
+const URLProtocol ff_jsfetch_protocol = {
+    .name               = "jsfetch",
+    .url_open2          = jsfetch_open,
+    .url_read           = jsfetch_read,
+    .url_close          = jsfetch_close,
+    .url_seek           = jsfetch_seek,
+    .priv_data_size     = sizeof(JSFetchContext),
+    .priv_data_class    = &jsfetch_context_class,
+    .flags              = URL_PROTOCOL_FLAG_NETWORK,
+    .default_whitelist  = "jsfetch,http,https,crypto"
+};
+#endif
Index: ffmpeg-6.0.1/libavformat/protocols.c
===================================================================
--- ffmpeg-6.0.1.orig/libavformat/protocols.c
+++ ffmpeg-6.0.1/libavformat/protocols.c
@@ -76,6 +76,10 @@ extern const URLProtocol ff_libzmq_proto
 extern const URLProtocol ff_ipfs_gateway_protocol;
 extern const URLProtocol ff_ipns_gateway_protocol;
 
+/* libav.js */
+extern const URLProtocol ff_jsfetch_protocol;
+/* /libav.js */
+
 #include "libavformat/protocol_list.c"
 
 const AVClass *ff_urlcontext_child_class_iterate(void **iter)

Index: ffmpeg-6.0.1/libavformat/mov.c
===================================================================
From https://trac.ffmpeg.org/ticket/7359
https://github.com/FFmpeg/FFmpeg/commit/380a518c439d4e5e3cf17b97e4a06259e8048f99
Note: this patch isn't in 7.1.1.
--- ffmpeg-6.0.1.orig/libavformat/mov.c
+++ ffmpeg-6.0.1/libavformat/mov.c
@@ -10416,15 +10416,15 @@ static int mov_switch_root(AVFormatContext *s, int64_t target, int index)
 
     if (index >= 0 && index < mov->frag_index.nb_items)
         target = mov->frag_index.item[index].moof_offset;
-    if (avio_seek(s->pb, target, SEEK_SET) != target) {
+    if (target >= 0 && avio_seek(s->pb, target, SEEK_SET) != target) {
         av_log(mov->fc, AV_LOG_ERROR, "root atom offset 0x%"PRIx64": partial file\n", target);
         return AVERROR_INVALIDDATA;
     }
 
     mov->next_root_atom = 0;
-    if (index < 0 || index >= mov->frag_index.nb_items)
+    if ((index < 0 && target >= 0) || index >= mov->frag_index.nb_items)
         index = search_frag_moof_offset(&mov->frag_index, target);
-    if (index < mov->frag_index.nb_items &&
+    if (index >= 0 && index < mov->frag_index.nb_items &&
         mov->frag_index.item[index].moof_offset == target) {
         if (index + 1 < mov->frag_index.nb_items)
             mov->next_root_atom = mov->frag_index.item[index + 1].moof_offset;
@@ -10554,10 +10554,43 @@ static int mov_read_packet(AVFormatContext *s, AVPacket *pkt)
     MOVStreamContext *sc;
     AVIndexEntry *sample;
     AVStream *st = NULL;
+    FFStream *avsti = NULL;
     int64_t current_index;
     int ret;
+    int i;
     mov->fc = s;
  retry:
+        if (s->pb->pos == 0) {
+
+        // Discard current fragment index
+        if (mov->frag_index.allocated_size > 0) {
+            av_freep(&mov->frag_index.item);
+            mov->frag_index.nb_items = 0;
+            mov->frag_index.allocated_size = 0;
+            mov->frag_index.current = -1;
+            mov->frag_index.complete = 0;
+        }
+
+        for (i = 0; i < s->nb_streams; i++) {
+            AVStream *avst = s->streams[i];
+            MOVStreamContext *msc = avst->priv_data;
+
+            // Clear current sample
+            mov_current_sample_set(msc, 0);
+            msc->ctts_index = 0;
+
+            // Discard current index entries
+            avsti = ffstream(avst);
+            if (avsti->index_entries_allocated_size > 0) {
+                av_freep(&avsti->index_entries);
+                avsti->index_entries_allocated_size = 0;
+                avsti->nb_index_entries = 0;
+            }
+        }
+
+        if ((ret = mov_switch_root(s, -1, -1)) < 0)
+            return ret;
+    }
     sample = mov_find_next_sample(s, &st);
     if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {
         if (!mov->next_root_atom)